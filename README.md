# Coverage Counters

## Cyclomatic Complexity

1. JaCoCo рассчитывает цикломатическую сложность метода с помощью следующего эквивалентного уравнения:
 
 ``v(G) = B - D + 1``
 
где  (B)- количество ветвей, а (D) - количество точек принятия решения.

Формула вычисления количества unit-тестов на основании значений , генерируемых JaCoCo по коду из домашнего задания выглядит следующим образом:

Циклическая сложность = 2(кол-во ветвей)-1(число точек решения)+1 = 2,

Таким образом метрика Jacoco рекомендует по 2 unit-теста на каждый метод, обозначенные на скриншотах ниже.

Для примера, был отключён один тест, чтобы увидеть изменения в отчёте. Так же опытным путём было выявлено, что If является точкой решения(D), которую мы использовали в формуле. А колличество веток указано в отчёте (Missed Branches).


![RadioProjectCodeJacoco](https://user-images.githubusercontent.com/61200143/95324863-087f7c80-08a9-11eb-95d6-49619b046a75.png)

![RadioProject сложность кода](https://user-images.githubusercontent.com/61200143/95324895-17662f00-08a9-11eb-9f74-bd0be3609583.png)


2. Рекомендуемый порог цикломатической сложности кода.

Чем ниже порог цикломатической сложности, тем легче в будущем будет менять структуру кода. Поэтому в большинтве источников указано, что порог не привышает 10. Если становится выше то код  упрощают. 

Например в этой статье [Цикломатическая сложность](https://codengineering.ru/post/42)

* 1-4 — это низкая цикломатическая сложность фрагмента кода;
* 5-7 — данная сложность вполне управляема, и фрагмент кода все еще прост для понимания;
* 6-10 — данная величина указывает на возможную сложность в понимании фрагмента кода;
* > 10 — фрагмент сложен для понимания.

В некоторых случаях порог может быть не больше 15, как написано в википедии ([статья о цикломатической сложности кода](https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C))
